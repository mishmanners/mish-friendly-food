import * as colors from "kleur/colors";
import { pathToFileURL } from "url";
import { normalizePath } from "vite";
import yargs from "yargs-parser";
import { z } from "zod";
import add from "../core/add/index.js";
import build from "../core/build/index.js";
import {
  createSettings,
  loadTSConfig,
  openConfig,
  resolveConfigPath,
  resolveFlags,
  resolveRoot
} from "../core/config/index.js";
import devServer from "../core/dev/index.js";
import { collectErrorMetadata } from "../core/errors.js";
import { debug, error, info } from "../core/logger/core.js";
import { enableVerboseLogging, nodeLogDestination } from "../core/logger/node.js";
import { formatConfigErrorMessage, formatErrorMessage, printHelp } from "../core/messages.js";
import { appendForwardSlash } from "../core/path.js";
import preview from "../core/preview/index.js";
import { ASTRO_VERSION, createSafeError } from "../core/util.js";
import * as event from "../events/index.js";
import { eventConfigError, eventError, telemetry } from "../events/index.js";
import { check } from "./check/index.js";
import { openInBrowser } from "./open.js";
import * as telemetryHandler from "./telemetry.js";
function printAstroHelp() {
  printHelp({
    commandName: "astro",
    usage: "[command] [...flags]",
    headline: "Build faster websites.",
    tables: {
      Commands: [
        ["add", "Add an integration."],
        ["build", "Build your project and write it to disk."],
        ["check", "Check your project for errors."],
        ["dev", "Start the development server."],
        ["docs", "Open documentation in your web browser."],
        ["preview", "Preview your build locally."],
        ["telemetry", "Configure telemetry settings."]
      ],
      "Global Flags": [
        ["--config <path>", "Specify your config file."],
        ["--root <path>", "Specify your project root folder."],
        ["--verbose", "Enable verbose logging."],
        ["--silent", "Disable all logging."],
        ["--version", "Show the version number and exit."],
        ["--help", "Show this help message."]
      ]
    }
  });
}
async function printVersion() {
  console.log();
  console.log(`  ${colors.bgGreen(colors.black(` astro `))} ${colors.green(`v${ASTRO_VERSION}`)}`);
}
function resolveCommand(flags) {
  const cmd = flags._[2];
  if (cmd === "add")
    return "add";
  if (cmd === "telemetry")
    return "telemetry";
  if (flags.version)
    return "version";
  else if (flags.help)
    return "help";
  const supportedCommands = /* @__PURE__ */ new Set(["dev", "build", "preview", "check", "docs"]);
  if (supportedCommands.has(cmd)) {
    return cmd;
  }
  return "help";
}
async function handleConfigError(e, { cwd, flags, logging }) {
  const path = await resolveConfigPath({ cwd, flags });
  if (e instanceof Error) {
    if (path) {
      error(logging, "astro", `Unable to load ${colors.bold(path)}
`);
    }
    console.error(
      formatErrorMessage(collectErrorMetadata(e, path ? pathToFileURL(path) : void 0)) + "\n"
    );
  }
}
async function runCommand(cmd, flags) {
  var _a;
  const root = flags.root;
  switch (cmd) {
    case "help":
      printAstroHelp();
      return process.exit(0);
    case "version":
      await printVersion();
      return process.exit(0);
  }
  let logging = {
    dest: nodeLogDestination,
    level: "info"
  };
  if (flags.verbose) {
    logging.level = "debug";
    enableVerboseLogging();
  } else if (flags.silent) {
    logging.level = "silent";
  }
  switch (cmd) {
    case "add": {
      telemetry.record(event.eventCliSession(cmd));
      const packages = flags._.slice(3);
      return await add(packages, { cwd: root, flags, logging, telemetry });
    }
    case "docs": {
      telemetry.record(event.eventCliSession(cmd));
      return await openInBrowser("https://docs.astro.build/");
    }
    case "telemetry": {
      const subcommand = (_a = flags._[3]) == null ? void 0 : _a.toString();
      return await telemetryHandler.update(subcommand, { flags, telemetry });
    }
  }
  let { astroConfig: initialAstroConfig, userConfig: initialUserConfig } = await openConfig({
    cwd: root,
    flags,
    cmd,
    logging
  }).catch(async (e) => {
    await handleConfigError(e, { cwd: root, flags, logging });
    return {};
  });
  if (!initialAstroConfig)
    return;
  telemetry.record(event.eventCliSession(cmd, initialUserConfig, flags));
  let initialTsConfig = loadTSConfig(root);
  let settings = createSettings({
    config: initialAstroConfig,
    tsConfig: initialTsConfig == null ? void 0 : initialTsConfig.config,
    tsConfigPath: initialTsConfig == null ? void 0 : initialTsConfig.path
  });
  switch (cmd) {
    case "dev": {
      async function startDevServer({ isRestart = false } = {}) {
        const { watcher, stop } = await devServer(settings, { logging, telemetry, isRestart });
        let restartInFlight = false;
        const configFlag = resolveFlags(flags).config;
        const configFlagPath = configFlag ? await resolveConfigPath({ cwd: root, flags }) : void 0;
        const resolvedRoot = appendForwardSlash(resolveRoot(root));
        const handleServerRestart = (logMsg) => async function(changedFile) {
          if (!restartInFlight && (configFlag ? configFlagPath && normalizePath(configFlagPath) === normalizePath(changedFile) : new RegExp(
            `${normalizePath(resolvedRoot)}.*astro.config.((mjs)|(cjs)|(js)|(ts))$`
          ).test(normalizePath(changedFile)))) {
            restartInFlight = true;
            console.clear();
            try {
              const newConfig = await openConfig({
                cwd: root,
                flags,
                cmd,
                logging,
                isConfigReload: true
              });
              info(logging, "astro", logMsg + "\n");
              let astroConfig = newConfig.astroConfig;
              let tsconfig = loadTSConfig(root);
              settings = createSettings({
                config: astroConfig,
                tsConfig: tsconfig == null ? void 0 : tsconfig.config,
                tsConfigPath: tsconfig == null ? void 0 : tsconfig.path
              });
              await stop();
              await startDevServer({ isRestart: true });
            } catch (e) {
              await handleConfigError(e, { cwd: root, flags, logging });
              await stop();
              info(logging, "astro", "Continuing with previous valid configuration\n");
              await startDevServer({ isRestart: true });
            }
          }
        };
        watcher.on("change", handleServerRestart("Configuration updated. Restarting..."));
        watcher.on("unlink", handleServerRestart("Configuration removed. Restarting..."));
        watcher.on("add", handleServerRestart("Configuration added. Restarting..."));
      }
      await startDevServer({ isRestart: false });
      return await new Promise(() => {
      });
    }
    case "build": {
      return await build(settings, { ...flags, logging, telemetry });
    }
    case "check": {
      const ret = await check(settings);
      return process.exit(ret);
    }
    case "preview": {
      const server = await preview(settings, { logging, telemetry });
      return await server.closed();
    }
  }
  throw new Error(`Error running ${cmd} -- no command found.`);
}
async function cli(args) {
  const flags = yargs(args);
  const cmd = resolveCommand(flags);
  try {
    await runCommand(cmd, flags);
  } catch (err) {
    await throwAndExit(cmd, err);
  }
}
async function throwAndExit(cmd, err) {
  let telemetryPromise;
  let errorMessage;
  function exitWithErrorMessage() {
    console.error(errorMessage);
    process.exit(1);
  }
  if (err instanceof z.ZodError) {
    telemetryPromise = telemetry.record(eventConfigError({ cmd, err, isFatal: true }));
    errorMessage = formatConfigErrorMessage(err);
  } else {
    const errorWithMetadata = collectErrorMetadata(createSafeError(err));
    telemetryPromise = telemetry.record(eventError({ cmd, err: errorWithMetadata, isFatal: true }));
    errorMessage = formatErrorMessage(errorWithMetadata);
  }
  setTimeout(exitWithErrorMessage, 400);
  await telemetryPromise.catch((err2) => debug("telemetry", `record() error: ${err2.message}`)).then(exitWithErrorMessage);
}
export {
  cli
};
